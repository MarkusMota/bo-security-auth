package mx.gob.banobras.securityauth.infraestructure.adapter.in.controller;

/**
 * SecurityAuthController.java:
 * 
 * Clase controller taht expose services to autentication user.
 * 
 * @author Marcos Gonzalez
 * @version 1.0, 13/06/2024
 * @see Documento "MAR - Marco Arquitectonico de Referencia"
 * @since JDK 17
 */

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Date;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

import jakarta.servlet.http.HttpServletRequest;
import mx.gob.banobras.securityauth.application.port.in.ISecurityAuthCasoUsoService;
import mx.gob.banobras.securityauth.common.util.ConstantsSecurityAuth;
import mx.gob.banobras.securityauth.infraestructure.config.dto.ErrorMessageDTO;
import mx.gob.banobras.securityauth.infraestructure.config.dto.LdapResponseDTO;
import mx.gob.banobras.securityauth.infraestructure.config.dto.SecurityAuthDTO;

@CrossOrigin(originPatterns = { "*" })
@RestController
public class SecurityAuthController implements ISecurityAuthController {

	/** Trace fo the application */
	Logger log = LogManager.getLogger(SecurityAuthController.class);
	
	/** Variable que contiene la url del ldap */
	@Value("${app.ldap.server}")
	String ldapServer;

	/** Injection variable of object HttpServletRequest */
	private HttpServletRequest httRequest;

	/** Injection variable para la interfaz iTokenizerInputPort */
	private final ISecurityAuthCasoUsoService iSecurityAuthInputPort;

	/** Consturctor de las interfaces que usa el controller */
	public SecurityAuthController(ISecurityAuthCasoUsoService iSecurityAuthInputPort, HttpServletRequest httRequest) {
		this.iSecurityAuthInputPort = iSecurityAuthInputPort;
		this.httRequest = httRequest;
	}

	/**
	 * Method to authenticated the user through LDAP
	 * 
	 * @param credentials    - Encrypted user credentials.
	 * @param app-name       - Name of the system that consume of service.
	 * @param consumer-id    - System layer that consumes the service.
	 * @param functional-id  - Functionality that consumes the service.
	 * @param transaction-id - Transaction identifier, generated by UUID.
	 * 
	 * @return back the object TokenizerResponseDTO with the token data
	 * @throws Exception  send during process of authentication.
	 * 
	 */
	public ResponseEntity<LdapResponseDTO> ldapAuth(
			@RequestHeader(value = "credentials") String credentials,
			@RequestHeader(value = "app-name") String appName, 
			@RequestHeader(value = "consumer-id") String consumerId,
			@RequestHeader(value = "functional-id") String functionalId,
			@RequestHeader(value = "transaction-id") String transactionId) {

		LdapResponseDTO ldapResponseDTO = null;
		SecurityAuthDTO securityAuthDTO = null;
		ErrorMessageDTO errorMessage = null;

		try {
			/** String remoteHost = request.getRemoteHost(); */
			String remoteHost = getIpRemoteAdress();
			// Agrega parametros para que se muestren en el Log
			ThreadContext.put(ConstantsSecurityAuth.TRANSACTION_ID.getName(), transactionId);
			ThreadContext.put("ip", remoteHost);

			log.info("Inicia autenticacion LDAP");
			securityAuthDTO = new SecurityAuthDTO(credentials, null, null, null, appName, consumerId, functionalId,
					transactionId, false);
			ldapResponseDTO = iSecurityAuthInputPort.authenticationLdap(securityAuthDTO);

			// Valida el resultado
			if (ldapResponseDTO.getStatusCode() == 200) {
				log.info("Datos correctos");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.OK);
			} else {
				log.info("No se encontraron detos");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
			}
		} catch (IllegalArgumentException eil) {
		
			log.error(ConstantsSecurityAuth.ILLEGAL_ARG_EXCEPTION.getName(), eil);
			errorMessage = new ErrorMessageDTO(HttpStatus.INTERNAL_SERVER_ERROR.value(), 
					new Date(), 
					eil.getMessage()+ " ## " + ldapServer);
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} catch (Exception e) {
			e.printStackTrace();
			log.error(ConstantsSecurityAuth.COMMUNICATION_EXCEPTION_LDAP.getName());
			log.error(ConstantsSecurityAuth.EXCEPTION.getName(), e);
			errorMessage = new ErrorMessageDTO(HttpStatus.SERVICE_UNAVAILABLE.value(), 
					new Date(), 
					e.getMessage() + " || " + ldapServer);
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.SERVICE_UNAVAILABLE.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} finally {
			ThreadContext.clearStack();
			log.info("Finaliza autenticacion LDAP");
		}
	}

	
	/**
	 * Method to authenticated the user through of Token and LDAP
	 * 
	 * @param credentials    - Encrypted user credentials.
	 * @param token-auth     - Authentication Token.
	 * @param app-name       - Name of the system that consume of service.
	 * @param consumer-id    - System layer that consumes the service.
	 * @param functional-id  - Functionality that consumes the service.
	 * @param transaction-id - Transaction identifier, generated by UUID.
	 * 
	 * @return back the object TokenizerResponseDTO with the token data
	 * @throws Exception  send during process of authentication.
	 * 
	 */
	public ResponseEntity<LdapResponseDTO> ldapTokenAuth(
			@RequestHeader(value = "credentials") String credentials,
			@RequestHeader(value = "token-auth") String tokenAuth, 
			@RequestHeader(value = "app-name") String appName,
			@RequestHeader(value = "consumer-id") String consumerId,
			@RequestHeader(value = "functional-id") String functionalId,
			@RequestHeader(value = "transaction-id") String transactionId) {

		LdapResponseDTO ldapResponseDTO = null;
		SecurityAuthDTO securityAuthDTO = null;
		ErrorMessageDTO errorMessage = null;

		try {
			/** String remoteHost = request.getRemoteHost(); */
			String remoteHost = getIpRemoteAdress();
			// Agrega parametros para que se muestren en el Log
			ThreadContext.put(ConstantsSecurityAuth.TRANSACTION_ID.getName(), transactionId);
			ThreadContext.put("ip", remoteHost);

			log.info("Inicia autenticacion Token-LDAP");
			securityAuthDTO = new SecurityAuthDTO(credentials, null, null, tokenAuth, appName, consumerId, functionalId,
					transactionId, false);
			ldapResponseDTO = iSecurityAuthInputPort.authenticationTokenLdap(securityAuthDTO);

			// Valida el resultado en la generacio del token
			if (ldapResponseDTO.getStatusCode() == 200) {
				log.info("Los datos exsiten en LDAP");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.OK);
			} else {
				log.info("Datos incorrectos");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
			}
		} catch (IllegalArgumentException eil) {
			log.error(ConstantsSecurityAuth.ILLEGAL_ARG_EXCEPTION.getName(), eil);
			errorMessage = new ErrorMessageDTO(HttpStatus.INTERNAL_SERVER_ERROR.value(), new Date(), eil.getMessage());
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} catch (Exception e) {
			log.error(ConstantsSecurityAuth.COMMUNICATION_EXCEPTION_LDAP.getName());
			log.error(ConstantsSecurityAuth.EXCEPTION.getName(), e);
			errorMessage = new ErrorMessageDTO(500, new Date(), "No hay conexión, Directorio Activo");
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.SERVICE_UNAVAILABLE.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} finally {
			ThreadContext.clearStack();
			log.info("Finaliza autenticacion Token-LDAP");
		}
	}
	
	/**
	 * Metodo para obtener la IP del srevicio que invoca al controller.
	 * 
	 * @throws UnknownHostException
	 * 
	 * @throws Exception            Excepción durante el proceso de generar el
	 *                              Token.
	 */
	private String getIpRemoteAdress() throws UnknownHostException {
		log.info(new StringBuilder().append("Busca IP :: ").append(httRequest.getRemoteHost()));
		log.info(new StringBuilder().append(ConstantsSecurityAuth.BUSCA_POR.getName())
				.append(ConstantsSecurityAuth.H_X_FORWARDED_FOR.getName()));
		String ipAddress = "";
		if (buscaEnHeaderPor(ConstantsSecurityAuth.H_X_FORWARDED_FOR.getName())) {
			ipAddress = httRequest.getHeader(ConstantsSecurityAuth.H_X_FORWARDED_FOR.getName());
		} else {
			if (buscaEnHeaderPor(ConstantsSecurityAuth.H_PROXY_CLIENT_IP.getName())) {
				ipAddress = httRequest.getHeader(ConstantsSecurityAuth.H_PROXY_CLIENT_IP.getName());
			} else {
				if (buscaEnHeaderPor(ConstantsSecurityAuth.H_WL_PROXY_CLIENT_IP.getName())) {
					ipAddress = httRequest.getHeader(ConstantsSecurityAuth.H_WL_PROXY_CLIENT_IP.getName());
				} else {
					if (buscaPorRemoteAddr()) {
						ipAddress = obtenValorPorRemoteAddr();
					}
				}
			}
		}
		log.info(new StringBuilder().append("La ip remota es :: ").append(ipAddress));
		return ipAddress;
	}

	/**
	 * Metodo para obtener la IP del srevicio que invoca al controller en el Header
	 * de la petición
	 * 
	 * @param cadenaABuscar cadena que contien el filtro a buscar en el header
	 * @return regresa un valor boolean, true si lo encuentra el valor
	 * 
	 */
	private boolean buscaEnHeaderPor(String cadenaABuscar) {
		String ipAddress = httRequest.getHeader(cadenaABuscar);
		boolean bandera = true;
		if (ipAddress == null || ipAddress.isEmpty() || ConstantsSecurityAuth.UNKNOWN.getName().equalsIgnoreCase(ipAddress)) {
			bandera = false;
		}
		return bandera;
	}

	/**
	 * Metodo para obtener la IP del srevicio que invoca al controller con el metodo
	 * geRemoteAdrr() de la petición
	 * 
	 * @return regresa un valor boolean, true si encuentra el valor
	 * 
	 */
	private boolean buscaPorRemoteAddr() throws UnknownHostException {
		String ipAddress = httRequest.getRemoteAddr();
		boolean bandera = false;
		if (ConstantsSecurityAuth.LOCALHOST_IPV4.getName().equals(ipAddress)
				|| ConstantsSecurityAuth.LOCALHOST_IPV6.getName().equals(ipAddress)) {
			log.info("Busca por getLocalHost()");
			InetAddress inetAddress = InetAddress.getLocalHost();
			ipAddress = inetAddress.getHostAddress();
			bandera = true;
		}
		if (ipAddress != null && ipAddress.length() > 15 && ipAddress.contains(ConstantsSecurityAuth.COMMA.getName())) {
			bandera = true;
		}
		return bandera;
	}

	/**
	 * Metodo para obtener la IP del srevicio que invoca al controller con el metodo
	 * geRemoteAdrr() de la petición
	 * 
	 * @return regresa un valor de la IP en formato IPV4 o IPV6
	 * 
	 * @throws UnknownHostException Exception en caso de no poder validar los datos.
	 */
	private String obtenValorPorRemoteAddr() throws UnknownHostException {
		String ipAddress = httRequest.getRemoteAddr();
		if (ConstantsSecurityAuth.LOCALHOST_IPV4.getName().equals(ipAddress)
				|| ConstantsSecurityAuth.LOCALHOST_IPV6.getName().equals(ipAddress)) {
			log.info("Busca por getLocalHost()");
			InetAddress inetAddress = InetAddress.getLocalHost();
			ipAddress = inetAddress.getHostAddress();
		}
		if (ipAddress != null && ipAddress.length() > 15 && ipAddress.contains(ConstantsSecurityAuth.COMMA.getName())) {
			ipAddress = ipAddress.substring(0, ipAddress.indexOf(ConstantsSecurityAuth.COMMA.getName()));
		}
		return ipAddress;
	}


	
	
	/**
	 * Method to authenticated the user and password through LDAP
	 * 
	 * @param credentials    - Encrypted user credentials.
	 * @param app-name       - Name of the system that consume of service.
	 * @param consumer-id    - System layer that consumes the service.
	 * @param functional-id  - Functionality that consumes the service.
	 * @param transaction-id - Transaction identifier, generated by UUID.
	 * 
	 * @return back the object TokenizerResponseDTO with the token data
	 * @throws Exception  send during process of authentication.
	 * 
	 */
	public ResponseEntity<LdapResponseDTO> ldapUserPwd(
			@RequestHeader(value = "credentials") String credentials,
			@RequestHeader(value = "app-name") String appName, 
			@RequestHeader(value = "consumer-id") String consumerId,
			@RequestHeader(value = "functional-id") String functionalId,
			@RequestHeader(value = "transaction-id") String transactionId) {

		LdapResponseDTO ldapResponseDTO = null;
		SecurityAuthDTO securityAuthDTO = null;
		ErrorMessageDTO errorMessage = null;

		try {
			/** String remoteHost = request.getRemoteHost(); */
			String remoteHost = getIpRemoteAdress();
			// Agrega parametros para que se muestren en el Log
			ThreadContext.put("transaction-id", transactionId);
			ThreadContext.put("ip", remoteHost);

			log.info("Inicia autenticacion LDAP");
			securityAuthDTO = new SecurityAuthDTO(credentials, null, null, null, appName, consumerId, functionalId,
					transactionId, true);
			ldapResponseDTO = iSecurityAuthInputPort.authenticationLdap(securityAuthDTO);

			// Valida el resultado
			if (ldapResponseDTO.getStatusCode() == 200) {
				log.info("Datos correctos");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.OK);
			} else {
				log.info("No se encontraron detos");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
			}
		} catch (IllegalArgumentException eil) {
		
			log.error(ConstantsSecurityAuth.ILLEGAL_ARG_EXCEPTION.getName(), eil);
			errorMessage = new ErrorMessageDTO(HttpStatus.INTERNAL_SERVER_ERROR.value(), 
					new Date(), 
					eil.getMessage()+ " ## " + ldapServer);
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} catch (Exception e) {
			e.printStackTrace();
			log.error(ConstantsSecurityAuth.COMMUNICATION_EXCEPTION_LDAP.getName());
			log.error(ConstantsSecurityAuth.EXCEPTION.getName(), e);
			errorMessage = new ErrorMessageDTO(HttpStatus.SERVICE_UNAVAILABLE.value(), 
					new Date(), 
					e.getMessage() + " || " + ldapServer);
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.SERVICE_UNAVAILABLE.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} finally {
			ThreadContext.clearStack();
			log.info("Finaliza autenticacion LDAP");
		}
	}

}
